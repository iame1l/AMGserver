## 扑克牌相关分析

```C++
do
{
	//iSend 是个推进的数.		
	iStation=rand( )%( iCardCount-iSend );
	iCard[iSend]=iCardList[iStation];
	iSend++;
    //最后一位的往前补(补到已经发出去的牌那)
	iCardList[iStation]=iCardList[iCardCount-iSend];
} while ( iSend<iCardCount );
```



### 牛牛类

```C++
//操作掩码(保险)
#define	UG_HUA_MASK					0xF0			//1111 0000
#define	UG_VALUE_MASK				0x0F			//0000 1111
```

```C++
//获取扑克数字(从1点开始算起)
inline int GetCardNum(BYTE iCard) { return (iCard&UG_VALUE_MASK)+1; }
```

```C++
int CUpGradeGameLogic::GetPoint(int Card)
{//主要是j,q,k当作是10处理
	if (Card == 0x00)
		return 0;
	switch (GetCardNum(Card))
	{
	case 10:
		return 10;
	case 11:
		return 10;
	case 12:
		return 10;
	case 13:
		return 10;
	case 14://?
		return 1;
	case 15:
		return 10;
	case 16:
		return 10;
	default:
		return GetCardNum(Card);
	}
}
```

```C++
//计算牌中点数//将点数加起来
int CUpGradeGameLogic::CountPoint(BYTE  iCardList[],int iCardCount)
{
	int point = 0;
	for (int i=0;i<iCardCount;i++)
	{
		int temp = GetPoint(iCardList[i]);
		if (temp == 14)
			temp = 1;
		point += temp;
	}
	return point;
}
```

```C++
//是否能筹出点数出来
int CUpGradeGameLogic::CanSumIn(BYTE iCardList[],int iCardCount,int iSelectNum)
{
	int total = CountPoint(iCardList,iCardCount);
	for (int i=0; i<3; i++)
	{
		for (int j=i+1; j<4; j++)
			for (int k = j+1; k<iCardCount; k++)
			{						             inttemp=GetPoint(iCardList[i])+GetPoint(iCardList[j])+GetPoint(iCardList[k]);
				if (temp==30||temp==10||temp==20)
				{
					return total-temp;
				}
			}
	}
	return -1;
}
```

