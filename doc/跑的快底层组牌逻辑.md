跑的快底层组牌逻辑

```C++
//提取1,2,3 or 4张相同数字的牌
int CUpGradeGameLogic::TackOutBySepcifyCardNumCount(BYTE iCardList[], int iCardCount, 
													BYTE iDoubleBuffer[], BYTE bCardNum, 
													bool bExtVal)
{
	int iCount = 0, temp[18] = {0};
	for(int i = 0; i < iCardCount; i++)
	{
		temp[GetCardBulk(iCardList[i])]++;
	}

	for(int i = 0; i < 18; i ++)
	{
		if(temp[i] == bCardNum) //现在要查找的牌型:one?double?three?four_bomb?
		{
			for(int j = 0; j < iCardCount; j++)
			{
				if(i == GetCardBulk(iCardList[j]))
					iDoubleBuffer[iCount++] = iCardList[j];
			}
		}
	}
	return iCount;
}
```



```C++
//提取指定长度的顺子(从大到小)
bool CUpGradeGameLogic::TackSequenceLen(BYTE byCardList[],int iCardCount,int iCount,BYTE byBuff[],int &iOut,int DeleteCount)
{
	BYTE temp[18]={0};
	BYTE TempCardData[18];
	memcpy(TempCardData,byCardList,sizeof(BYTE) * iCardCount);

	for(int i= 0;i < iCardCount;i++)
	{
		temp[GetCardBulk(byCardList[i])]++;
	}

	for(int i = 0; i < 15 ; i ++)
	{
		if(temp [i]!= 0 &&temp[i] !=iCount)	//非指定顺
		{
			return false;
		}
	}
	int iMaxLength = (iCardCount - DeleteCount) / iCount;
	
	int iIndex = 0;
	int iCountSame = 0;

	for(int i = 15;i >= 0; i--)
	{
		iCountSame = 0;
		if(temp[i] != 0)//有值
		{
			for(int j = i;j >= 0  ;j --)			//检测指定长度是否连继
			{
				if(temp[j] != iCount)
				{
					break;
				}
				iCountSame ++;
				if(iMaxLength == iCountSame)
				{
					iMaxLength = iCountSame;
					iIndex = i;
					break;
				}
			}		
		}

		i -= iCountSame;
	}

	iOut = 0;

	for(int i = 0;i < iMaxLength;i ++)
	{
		for(int j = 0;j < iCardCount;j ++)
		{
			if(0xff != TempCardData[j])
			{
				if(iIndex == GetCardBulk(TempCardData[j]))
				{
					byBuff[iOut ++] = TempCardData[j];
					TempCardData[j] = 255;
				}			
			}
		}
		iIndex--;
	}

	return true;
}
```



```C++
//提取所有炸弹为提反单顺,双顺,三顺做准备
BOOL CUpGradeGameLogic::TackOutAllBomb(BYTE iCardList[],int iCardCount,
									   BYTE iResultCard[],int &iResultCardCount,int iNumCount)
{
	iResultCardCount=0;
	BYTE bCardBuffer[CARD_COUNT];
	BYTE bombcount=GetBombCount(iCardList,iCardCount,iNumCount);
	if(bombcount<0)
		return false;
	for(int i=iNumCount;i < 9;i++)
	{
		int count=TackOutBySepcifyCardNumCount(iCardList,iCardCount,bCardBuffer,i);
		if(count > 0)
		{
			::CopyMemory(&iResultCard[iResultCardCount],bCardBuffer,sizeof(BYTE)*count);
			iResultCardCount+=count;
			break;
		}
	}
	return true;
}
```



```C++
//得到顺子的起始位置
int CUpGradeGameLogic::GetSequenceStartPostion(BYTE iCardList[],int iCardCount,int xSequence)
{
	BYTE temp[18]={0};
	int Postion=0;
	for(int i=0;i<iCardCount;i++)
	{
		temp[GetCardBulk(iCardList[i])]++;
	}

	for(int i=0;i<18;i++)
	{
		if(temp[i] == xSequence)
			return i;
	}
	return Postion;
}
```



```C++
//获取指定牌张数牌大小
BYTE CUpGradeGameLogic::GetBulkBySpecifyCardCount(BYTE iCardList[],int iCardCount,int iCount)
{
	BYTE temp[18] = {0};
	for(int i = 0;i < iCardCount;i ++)
		temp[GetCardBulk(iCardList[i])]++;

	for(int i = 17;i> 0;i--)
		if(temp[i] == iCount)
			return i;

	return 0;
}
```



```C++
//是否可以出牌
BOOL CUpGradeGameLogic::CanOutCard(BYTE iOutCard[], int iOutCount,  //要出的牌
								   BYTE iBaseCard[], int iBaseCount,//要压的牌
								   BYTE iHandCard[], int iHandCount,//手中的牌
								   bool bFirstOut)
{
	BYTE iOutCardShape = GetCardShape(iOutCard, iOutCount);

	if(iOutCardShape == UG_ERROR_KIND) //牌型不对
	{
		return FALSE;
	}

	if(bFirstOut)
	{
		return TRUE;
	}

	BYTE iBaseCardShape = GetCardShape(iBaseCard, iBaseCount); //桌面上的牌型

	if( iBaseCardShape != iOutCardShape)						//不一样的情况
	{
		if(UG_BOMB != iOutCardShape)
		{
			return false;
		}
		else
		{
			return true;
		}
	}	

	switch(iBaseCardShape)			//处理牌形一致
	{
	case UG_ONLY_ONE:		 //单张
	case UG_DOUBLE:			 //对牌
	case UG_THREE:			 //三张	
	case UG_BOMB:			 //炸弹
	case UG_STRAIGHT:		 //顺子
	case UG_DOUBLE_SEQUENCE: //连对
	case UG_THREE_SEQUENCE:  //连三  
		if(iOutCount != iBaseCount)
		{
			return FALSE;
		}
		return GetBulkBySepcifyMinOrMax(iBaseCard, iBaseCount, 1) < GetBulkBySepcifyMinOrMax(iOutCard, iOutCount, 1);
		break;
	case UG_THREE_ONE:		//三带一
	case UG_THREE_TWO:		//三带二
	case UG_THREE_DOUBLE:	//三带对
		if(iOutCount != iBaseCount)
		{
			return FALSE;
		}		
		return GetBulkBySpecifyCardCount(iBaseCard, iBaseCount,3)<GetBulkBySpecifyCardCount(iOutCard, iOutCount,3);
		break;
	case UG_THREE_ONE_SEQUENCE: //2+个三带一
	case UG_THREE_TWO_SEQUENCE: //2+个三带二
	case UG_THREE_DOUBLE_SEQUENCE://三带对顺
	case UG_THREE_SEQUENCE_DOUBLE_SEQUENCE:		//三顺带二顺(蝴蝶)
		{
			if(iOutCount != iBaseCount)
			{
				return FALSE;
			}
			BYTE iBuffer_1[CARD_COUNT];
			BYTE iBuffer_2[CARD_COUNT];
			memset(iBuffer_1,0,sizeof(iBuffer_1));
			memset(iBuffer_2,0,sizeof(iBuffer_2));

			int TackOutCount_1 = TackOutBySepcifyCardNumCount(iBaseCard,iBaseCount,iBuffer_1,3);		//提示都是三张一样的牌
			int TackOutCount_2 = TackOutBySepcifyCardNumCount(iOutCard,iOutCount,iBuffer_2,3);

			BYTE iBuffer_3[CARD_COUNT];
			BYTE iBuffer_4[CARD_COUNT];
			int TackOutCount_3 = 0;
			int TackOutCount_4 = 0;
			memset(iBuffer_3,0,sizeof(iBuffer_3));
			memset(iBuffer_4,0,sizeof(iBuffer_4));

			GetMaxThreeSequence(iBuffer_1, TackOutCount_1,3,iBuffer_3,TackOutCount_3);					//提取组成最大的连队
			GetMaxThreeSequence(iBuffer_2, TackOutCount_2,3,iBuffer_4,TackOutCount_4);

			return(GetBulkBySpecifySequence(iBuffer_3, TackOutCount_3,3) < GetBulkBySpecifyCardCount(iBuffer_4, TackOutCount_4,3));
		}
		break;
	}

	return false;
}
```





```C++
//提取蝴蝶
BOOL  CUpGradeGameLogic::TrackOut3Sequence2Sequence(BYTE iCardList[], int iCardCount, BYTE iBaseCard[], int iBaseCount, BYTE iResultCard[], int &iResultCardCount)
{
	iResultCardCount = 0;
	if(iCardCount < iBaseCount)	//张数不够
		return false;
	BYTE tmpBaseCard[CARD_COUNT];
	int tmpbaseCardCount =0,destCardCount =0;
	//将桌面牌的三条分离出来
	tmpbaseCardCount =TackOutBySepcifyCardNumCount(iBaseCard,iBaseCount,tmpBaseCard,3);
	if(tmpbaseCardCount < 6)	//至少六张以上
		return FALSE;
	//先提取比桌面大的三顺
	if(!TackOutSequence(iCardList,iCardCount,tmpBaseCard,tmpbaseCardCount,iResultCard,iResultCardCount,3))
		return FALSE;
	//将手牌复制一份(移除三顺牌)
	BYTE TMP[CARD_COUNT];
	int TmpCount = iCardCount ;
	::CopyMemory(TMP,iCardList,sizeof(BYTE)*iCardCount);
	RemoveCard(iResultCard,iResultCardCount,TMP,TmpCount);
	TmpCount -= iResultCardCount;
	destCardCount = iBaseCount - iResultCardCount;	//补牌数量

	BYTE twoList[CARD_COUNT];
	int twoCount;
	//将桌面牌的二顺分离出来
	tmpbaseCardCount =TackOutBySepcifyCardNumCount(iBaseCard,iBaseCount,tmpBaseCard,2);
	if(!TackOutSequence(TMP,TmpCount,tmpBaseCard,tmpbaseCardCount,twoList,twoCount,2,true))
		return false;
	//	int TwoSequenceLen = (iBaseCount- tmpbaseCardCount)/2;
	//	tmpbaseCardCount =TackOutBySepcifyCardNumCount(TMP,TmpCount,tmpBaseCard,3);
	::CopyMemory(&iResultCard[iResultCardCount],twoList,sizeof(BYTE)*twoCount);
	iResultCardCount +=twoCount;
	return true;
}
```



```C++
#define UG_VARIATION_STRAIGHT					3				//变种顺子(A2345)顺子中最小
#define UG_STRAIGHT								4               //顺子,5+张连续牌
#define UG_FLUSH								5				//同花(非连)
#define UG_STRAIGHT_FLUSH						6               //同花顺,花色相同的顺子

#define UG_THREE								7				//三张
#define UG_THREE_ONE							8               //3 带 1
#define UG_THREE_TWO							9               //3 带 2
#define UG_THREE_DOUBLE							10				//3 带1对

#define UG_VARIATION_DOUBLE_SEQUENCE			11				//变种双顺(AA22)最小
#define UG_DOUBLE_SEQUENCE						12				//连对,2+个连续的对子

#define UG_VARIATION_THREE_SEQUENCE				13				//变种三顺(AAA222最小)
#define UG_THREE_SEQUENCE						14				//连三张，2+个连续的三张

#define UG_VARIATION_THREE_ONE_SEQUENCE			15				//变种三顺带一
#define UG_THREE_ONE_SEQUENCE					16              //2+个连续的三带一

#define UG_VARIATION_THREE_TWO_SEQUENCE			17				//变种三顺带二
#define UG_THREE_TWO_SEQUENCE					18				//2+个连续的三带二

#define UG_VARIATION_THREE_DOUBLE_SEQUENCE		19				//变种三连张带对
#define UG_THREE_DOUBLE_SEQUENCE				20				//三连张带对



#define UG_VARIATION_THREE_SEQUENCE_DOUBLE_SEQUENCE		21		//变种蝴蝶(三顺带二顺)
#define UG_THREE_SEQUENCE_DOUBLE_SEQUENCE		22				//蝴蝶(三顺带二顺)

#define UG_THREE_SEQUENCE_EX					23				//333444555666A 或 333444555777 或 333444555776 
```

```C++
//是否为顺子
BOOL CUpGradeGameLogic::IsSequence(BYTE iCardList[], int iCardCount, int iCount)
{
	BYTE temp[18]={0};
	for(int i= 0;i < iCardCount;i++)
	{
		temp[GetCardBulk(iCardList[i])]++;
	}

	for(int i = 0; i < 15 ; i ++)
	{
		if(temp [i]!= 0 &&temp[i] !=iCount)	//非指定顺
			return false;
	}

	int len = iCardCount / iCount;
	//TCHAR sz[200];
	//wsprintf(sz,"iCardCount=%d,iCount=%d,len=%d",iCardCount,iCount,len);
	//WriteStr(sz);
	for(int i=0;i<15;i++)
	{
		if(temp[i] != 0)//有值
		{
			//if(temp[i] == iCount )
			//{	
			for(int j = i;j < i + len  ;j ++)			//检测指定长度是否连继
			{
				if(temp[j] != iCount || j >=15 )
					return false;
			}
			return true;
			//}else 
			//	return false;
		}
	}
	return false;
}
```

