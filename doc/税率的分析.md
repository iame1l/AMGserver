## 税率的分析

long int						m_dwTax;								///< 每局玩家缴税







long int							dwTax;								//每人实缴税收

```C++
bool CGameDesk::ChangeUserPointint64(__int64 *arPoint, bool *bCut, int nTaxIndex,int iCount)
{
	/// 计算本局游戏赢家所赢金币的总和
	/// 计算本局游戏输家所输金币的总和
	/// 判断每个输家身上的金币是否足够输
	/// 若有输家金币不够支付，则赢家要相应减少所得
	/// 更新m_pInfo里各玩家数据，供游戏中读取到正确的值
	/// 统一把所有玩家的结算结果存入数据库
	/// 发送消息到客户端，表示有人输钱或赢钱了

	if (m_pDataManage->m_InitData.dwRoomRule & GRR_CONTEST || m_pDataManage->m_InitData.dwRoomRule & GRR_TIMINGCONTEST)
	{
		return ChangeUserPointContest(arPoint, bCut, nTaxIndex);
	}

	m_tEndTime = CTime::GetCurrentTime();
	
	/// 取当前时间
	CString stime;
	stime.Format("%d",CTime::GetCurrentTime());
	int curtime=atoi(stime);

	/// 是否为大家都要交台费的房间规则，一般都为赢家交台费
	bool bIsAllNeedTax = (m_pDataManage->m_InitData.dwRoomRule & GRR_ALL_NEED_TAX) > 0;
	bool bTaxMain = false; ///< 是否只是庄家扣税。

	bool bNotCostPoint = (m_pDataManage->m_InitData.dwRoomRule & GRR_NOT_COST_POINT) > 0; /// 金币场不扣积分

	BYTE i=0;	///< 循环变量

	/// 输的总分和金币
	__int64 i64TotalLosePoint = 0;
	__int64 i64TotalWinPoint = 0;
	__int64 i64TotalLoseMoney = 0;
	__int64 i64TotalWinMoney = 0;

	/// 实际玩家有多少
	int nTotalPlayerCount = 0;
	/// 断线玩家是哪个
	BYTE bCutDeskStation = 255;

	for (i=0; i<m_bMaxPeople; ++i)
	{
		if (m_pUserInfo[i] == NULL)
			continue;
		++nTotalPlayerCount;
		if (bCut[i])
		{
			bCutDeskStation = i;
		}

		if (!bTaxMain && nTaxIndex>=0)
		{
			if (i == nTaxIndex) ///< 只扣该玩家的税。
			{
				bTaxMain = true;
			}
		}

	}

	__int64 arLoseMoney[MAX_PEOPLE];
	__int64 arTaxCount[MAX_PEOPLE];
	ZeroMemory(arLoseMoney, sizeof(arLoseMoney));
	ZeroMemory(arTaxCount, sizeof(arTaxCount));
	/// 用户ID数组
	long arUserID[MAX_PEOPLE];
	ZeroMemory(arUserID, sizeof(arUserID));
	long arLogonTime[MAX_PEOPLE];
	ZeroMemory(arLogonTime, sizeof(arLogonTime));
	/// 是否有人不够钱
	bool bSomeOneNoEnoughMoney = false;

	__int64 i64Tmp = 1;	/// 为了防止上溢，引入一个int64类型的数，免得写好多个强制类型转换

	long int dwNowTime=(long int)time(NULL);

	if (m_pDataManage->m_nRate < 100)
	{
		m_pDataManage->m_nRate = 100;
	}


	/// 金币场才需要计算，
	/// 根据应输积分，计算应输玩家应输的钱，同时考虑身上的钱是否够支付
	if(m_pDataManage->m_InitData.uComType == TY_MONEY_GAME )
	{
		for (i=0; i<m_bMaxPeople; ++i)
		{
			if (NULL==m_pUserInfo[i] || (m_bIsMidEnter[i]==true)&&m_pDataManage->m_InitData.uDeskType!=DESK_TYPE_BJL)
			{
				continue;
			}
			/// 计算应输者金币是否够
			if (arPoint[i]<=0)
			{
				
				arLoseMoney[i] = arPoint[i]*m_DeskBasePoint;	///< 该数为负数

				/// 是不是大家都要扣税，无论输赢
				if (bIsAllNeedTax && (m_pDataManage->m_InitData.uTax>0) && (nTaxIndex < 0 || nTaxIndex == i))
				{
					arTaxCount[i] = i64Tmp * m_pDataManage->m_InitData.uTax;//这里是找税率的
					arLoseMoney[i] -= arTaxCount[i];
				}

				/// 检查该玩家的钱是否已经不够了
				if (m_pUserInfo[i]->m_UserData.i64Money < (0-arLoseMoney[i])&& !(m_pDataManage->m_InitData.dwRoomRule&GRR_GAME_BUY)) ///<钱不够输了
				{
					bSomeOneNoEnoughMoney = true;
					if (m_pUserInfo[i]->m_UserData.i64Money <= 0) ///<这种情况应该不会出现
					{
						arLoseMoney[i] = 0;	///< 一分钱都没有了
					}
					else
					{
						arLoseMoney[i] = 0-m_pUserInfo[i]->m_UserData.i64Money; ///< 把玩家身上的钱都扣光
					}
				}

				/// 总共输的分数和钱数，如果有人不够钱，用来计算赢家分配钱的比例
				i64TotalLosePoint -= arPoint[i];
				i64TotalLoseMoney -= arLoseMoney[i];
			}
		}
	}

	/// 所有输家该输的金币都已经确定，可以开始计算赢家的收入了
	for (i=0; i<m_bMaxPeople; ++i)
	{
		if (NULL==m_pUserInfo[i])
		{
			continue;
		}
		arUserID[i] = m_pUserInfo[i]->m_UserData.dwUserID; ///<把有效玩家的dwUsreID放到数组中
		arLogonTime[i] = m_pUserInfo[i]->m_dwLogonTime; ///<把有效玩家的登录时间放到数组中
		/// 赢钱的需要重新计算，输家已经计算过了
		if ((m_pDataManage->m_InitData.uComType == TY_MONEY_GAME) && (arPoint[i]>0) && !bTaxMain)
		{

			/// 判断是否有玩家不够钱，若有，则赢不了这么多钱
			if (bSomeOneNoEnoughMoney)
			{

				if (i64TotalLosePoint != 0)
					arLoseMoney[i] = i64TotalLoseMoney*arPoint[i]/i64TotalLosePoint;
				else
					arLoseMoney[i] = 0;

			}
			else
			{
				arLoseMoney[i] = arPoint[i]*m_DeskBasePoint;
			}
			i64Tmp = 1;
			/// 计算好该赢金额后，扣税
			/// 大家都交
			if (bIsAllNeedTax)
			{
				if (m_pDataManage->m_InitData.uTax>0)
				{
					arTaxCount[i] = i64Tmp * m_pDataManage->m_InitData.uTax;
					arLoseMoney[i] -= arTaxCount[i];
			
				}
			}
			else
			{
				if ((m_pDataManage->m_InitData.uTax>0) && (arLoseMoney[i]>=2))
				{	
					arTaxCount[i] = i64Tmp * arLoseMoney[i] * m_pDataManage->m_InitData.uTax/m_pDataManage->m_nRate;
					arLoseMoney[i] -= arTaxCount[i];
				}
			}
		}
		else if ((m_pDataManage->m_InitData.uComType == TY_MONEY_GAME) && (arPoint[i]>0) && bTaxMain)///< 只扣该玩家的税
		{

			/// 判断是否有玩家不够钱，若有，则赢不了这么多钱
			if (bSomeOneNoEnoughMoney)
			{

				if (i64TotalLosePoint != 0)
					arLoseMoney[i] = i64TotalLoseMoney*arPoint[i]/i64TotalLosePoint;
				else
					arLoseMoney[i] = 0;

			}
			
			else
			{
				arLoseMoney[i] = arPoint[i]*m_DeskBasePoint;
			}
			i64Tmp = 1;
            if (bIsAllNeedTax && i == nTaxIndex)
            {
                if (m_pDataManage->m_InitData.uTax>0)
                {
                    arTaxCount[i] = i64Tmp * m_pDataManage->m_InitData.uTax;

                    arLoseMoney[i] -= arTaxCount[i];

                }
            }
            else
            {

			    if (i == nTaxIndex && m_pDataManage->m_InitData.uTax>0) ///< 只扣该玩家的税。
			    {
				    if (arLoseMoney[i] >= 2)
				    {
					    arTaxCount[i] = i64Tmp * arLoseMoney[i] * m_pDataManage->m_InitData.uTax/m_pDataManage->m_nRate;

					    arLoseMoney[i] -= arTaxCount[i];
				    }
			    }
            }
		}


		/// 给成员变量赋值
		m_dwTaxCom[i] = arTaxCount[i];

		if(bNotCostPoint)		//金币场不扣积分
		{
			m_dwChangePoint[i] = 0;
		}
		else
		{
			m_dwChangePoint[i] = arPoint[i];
		}

		/// 更新m_pUserInfo里的数据
		m_pUserInfo[i]->ChangePoint(m_dwChangePoint[i], m_dwTaxCom[i], arPoint[i]>0, arPoint[i]<0,arPoint[i]==0, bCut[i], dwNowTime-m_dwBeginTime, arLoseMoney[i],m_bIsBuy);

		/// 经过再次判断后，再赋值给结算
		m_dwChangeMoney[i] = arLoseMoney[i];
	}
	/// 统一把所有玩家的结算结果存入数据库

	/// 在上面的循环中已经统计过玩家人数nTotalPlayerCount
	UpdateUserInfo_t *pUpdateUserInfo = NULL;
	int nIndex=0;
	

	pUpdateUserInfo = new UpdateUserInfo_t[nTotalPlayerCount];
	for (i=0; i<m_bMaxPeople; ++i)
	{
		if (NULL == m_pUserInfo[i])
		{
			continue;
		}
		//结算之后，金币不足房间下限，自动赠送 
		__int64 i64Money = m_pUserInfo[i]->m_UserData.i64Money + m_pUserInfo[i]->m_UserData.i64Bank;
		if(m_pDataManage->m_InitData.bSendAlms && (i64Money <= m_pDataManage->m_InitData.iAlmsMinMoney)
			&& (m_pDataManage->m_InitData.uComType == TY_MONEY_GAME)
			&& !(m_pDataManage->m_InitData.dwRoomRule&GRR_EXPERCISE_ROOM))
		{
			pUpdateUserInfo[nIndex].bISAutoSendMoney = true;
		}

		/// 按次序赋值
		pUpdateUserInfo[nIndex].dwUserID			= m_pUserInfo[i]->m_UserData.dwUserID;
		pUpdateUserInfo[nIndex].dwOnLineTimeCount	= dwNowTime-m_pUserInfo[i]->m_dwLogonTime;
		__int64 iPoint = arPoint[i];
		
		if (bNotCostPoint)//金币场不扣积分
		{
			pUpdateUserInfo[nIndex].dwChangePoint = 0;
		}
		else 
		{
			pUpdateUserInfo[nIndex].dwChangePoint = iPoint;
		}

		pUpdateUserInfo[nIndex].dwChangeMoney = arLoseMoney[i];
		pUpdateUserInfo[nIndex].dwChangeTaxCom = m_dwTaxCom[i];

		if (arPoint[i]==0)
		{
			pUpdateUserInfo[nIndex].uMidCount = 1;
		}
		else if (arPoint[i]>0)
		{
			pUpdateUserInfo[nIndex].uWinCount = 1;
		}
		else
		{
			pUpdateUserInfo[nIndex].uLostCount = 1;
		}

		pUpdateUserInfo[nIndex].uCutCount = bCut[i]? 1 : 0;
		++nIndex;
	}


	/// 批量更新用户数据
	UpdateAllUserInfo(pUpdateUserInfo, nTotalPlayerCount, m_tEndTime.GetTime() - m_tBeginTime.GetTime());

	
	m_dwTax = 0;
	/// 发送用户更改数据到客户端

	for (i=0; i<m_bMaxPeople; ++i)
	{
		if (NULL == m_pUserInfo[i])
		{
			continue;
		}
		
		m_dwTax += m_dwTaxCom[i];

		m_pUserInfo[i]->m_dwLogonTime=(long int)time(NULL);
		//发送消息
		MSG_GR_R_UserPoint UserPoint;
		ZeroMemory(&UserPoint, sizeof(UserPoint));
		UserPoint.dwUserID = m_pUserInfo[i]->m_UserData.dwUserID;
		UserPoint.dwPoint = arPoint[i];

		if (bNotCostPoint)
		{
			UserPoint.dwPoint = 0;
		}
		
		UserPoint.dwMoney = arLoseMoney[i];


		if (arPoint[i] > 0)
			UserPoint.bWinCount = 1;

		if (arPoint[i] < 0)
		{
			UserPoint.bLostCount = 1;
		}

		if (arPoint[i] == 0) 
			UserPoint.bMidCount = 1;

		if (bCut[i] == true) 
			UserPoint.bCutCount = 1;

		UserPoint.dwSend = -1;

		m_pDataManage->m_TCPSocket.SendDataBatch(&UserPoint,sizeof(UserPoint),MDM_GR_ROOM,ASS_GR_USER_POINT,0);
	}

	//战绩
	if ((m_pDataManage->m_InitData.dwRoomRule & GRR_GAME_BUY) && m_bIsBuy)
	{
		m_iRunGameCount++;
	}
	//保存战绩
	UpdateGameRecord(arPoint);

	return true;
}
```





```C++
//扣税计算公式：扣税金币 =  房间倍数 * 点数 * 比率(点数:金币) * 税率
		if(nCount > 0)
		{
			nCGTax = (i64Tmp  * m_DeskBasePoint * nBasePoint * nPointRate * m_pDataManage->m_InitData.uTax / nCount ) / m_pDataManage->m_nRate;
		}
```

