大厅的思路

```C++
	// 游戏类型列表
	void H_P_M_ListKind(const NetMessageHead* messageHead, void* object, INT objectSize);

	// 游戏名称列表
	void H_P_M_ListName(const NetMessageHead* messageHead, void* object, INT objectSize);
```




```C++
	// 游戏类型列表(思路的形成)
	void HNPlatformLogic::H_P_M_ListKind(const NetMessageHead* messageHead, void* object, INT objectSize)
	{
		ComKindInfo* pData = (ComKindInfo*)object;
		INT Count = objectSize / sizeof(ComKindInfo);
		Count = Count < 0 ? 0 : Count;
		while (Count-- > 0)
		{
			ComKindInfo* pInfo = pData++;
			GamesInfoModule()->addGameKind(pInfo);
		}
	}
```





```C++
	// 游戏名称列表
	void HNPlatformLogic::H_P_M_ListName(const NetMessageHead* messageHead, void* object, INT objectSize)
	{
		ComNameInfo* pData = (ComNameInfo*)object;
		INT Count = objectSize / sizeof(ComNameInfo);
		Count = Count < 0 ? 0 : Count;
		
        //将每个游戏拉进去显示
		while (Count-- > 0)
		{
			CHECKUTF8(pData->szGameName);
			GamesInfoModule()->addGameName(pData++);
		}

		if (ERR_GP_LIST_FINISH == messageHead->bHandleCode)
		{
			dispatchMessage([](IPlatformMessageDelegate* delegate) -> bool
			{
				delegate->I_P_M_GameList();
				return false;
			});
		}
	}
```





```C++
	void HNGamesInfoModule::addGameName(ComNameInfo* nameInfo)
	{
		assert(nameInfo != nullptr);
		if (nullptr != nameInfo)
		{
			ComNameInfo* game = findGameName(nameInfo->uNameID);
			if (nullptr != game)
			{
				*game = *nameInfo;
			}
			else
			{
				ComNameInfo* game = new ComNameInfo();
				*game = *nameInfo;
				_gameNames->push_back(game);
			}
		}
	}
```



```C++
void HNPlatformLogic::H_P_M_List(const NetMessageHead* messageHead, void* object, INT objectSize)
```





```C++
		//入口

case MDM_GP_LIST: 
			H_P_M_List(&socketMessage->messageHead, socketMessage->object, socketMessage->objectSize); 
			break;
```



```C++
virtual void onSocketMessage(HNSocketMessage* socketMessage) override;
```





```C++
//界面
sendData(MDM_GP_LIST, ASS_GP_LIST_KIND);
```







```C++
//创建游戏列表
void GameLists::createGameList(int KindID)
{
	std::vector<ComNameInfo*> gameNames;

	// 已过滤掉纯vip房间（比赛场不用过滤，接收到房间列表消息时已经过滤）
	gameNames = GameCreator()->getNormalGames(KindID);

	int currentIndex = 0;
	int pageCount = (gameNames.size() / 8);
	int remainder = (gameNames.size() % 8);

	std::vector<ComNameInfo*> pages;

	if (pageCount > 0)
	{
		for (int currentPage = 0; currentPage < pageCount; currentPage++)
		{
			pages.clear();
			for (int game = 0; game < 8; game++, currentIndex++)
			{
				ComNameInfo* gameInfo = gameNames[currentIndex];
				pages.push_back(gameInfo);
			}
			createGamePage(pages);
		}
	}

	if (remainder > 0)
	{
		pages.clear();
		for (int game = 0; game < remainder; game++, currentIndex++)
		{
			ComNameInfo* gameInfo = gameNames[currentIndex];
			pages.push_back(gameInfo);
		}
		createGamePage(pages);
	}

	checkUpdateGame();
	_currentPageIdx = Configuration::getInstance()->getValue("gamePageIdx", Value(0)).asInt();
	_pageViewGames->setCurrentPageIndex(_currentPageIdx);
}
```





```C++
//创建游戏列表的表层
static GameLists* create(int KindID, Layout* layout);


GameLists* GameLists::create(int KindID, Layout* layout)
{
	auto pRet = new (std::nothrow) GameLists();
	if (pRet && pRet->init(KindID, layout))
	{
		pRet->autorelease();
	}
	else
	{
		CC_SAFE_DELETE(pRet);
	}
	return pRet;
}

//表层之一
bool GameLists::init(int KindID, Layout* layout)
{
	if (!HNLayer::init()) return false;
    
	HNPlatformConfig()->setSceneState(PlatformConfig::SCENE_STATE::INPLATFORM);
	_layout = layout;
	_layout->setVisible(true);
	_pageViewGames = dynamic_cast<PageView*>(layout->getChildByName("PageView_gamelist"));
	_pageViewGames->setCustomScrollThreshold(15);
	_pageViewGames->scrollToPage(0);
	_pageViewGames->removeAllPages();
	_pageViewGames->setIndicatorEnabled(true);
	_pageViewGames->setIndicatorIndexNodesTexture(GAME_PAGESPROMPT_PATH);
	_pageViewGames->setIndicatorIndexNodesScale(0.75f);
	_pageViewGames->setIndicatorSelectedIndexColor(Color3B::WHITE);
	_pageViewGames->setIndicatorPosition(Vec2(_pageViewGames->getContentSize().width * 0.5f, _pageViewGames->getContentSize().height * 0.03f));

	createGameList(KindID);

	return true;
}
```



```C++
#define GameCreator()	HNGameCreator::getInstance()
```



//分类的按钮所在

```C++
// 显示游戏分类动画
void GamePlatform::showGameListAction(bool show/* = true*/)
{
	/* Eil @ 
	auto lobbyUi = dynamic_cast<Layout*>(_layout_platform->getChildByName("Panel_lobby"));
	lobbyUi->setVisible(show);
	if (show)
	{
		for (int i = 0; i < 5; i++)
		{
			auto pos = _games[i]->getPosition();
			_games[i]->setVisible(true);
			_games[i]->setPositionX(pos.x + _winSize.width);
			_games[i]->runAction(Sequence::create(MoveTo::create(0.2f, Vec2(pos.x - 50.f, pos.y)),
				EaseBackOut::create(MoveTo::create(0.3f * (i + 1), pos)), nullptr));
		}
	}
	*/
}
```





```C++
//创建游戏列表层
void GamePlatform::createGameListLayer()
{
	LoadingLayer::removeLoading(Director::getInstance()->getRunningScene());

	auto games = GameCreator()->getNormalGames(_KindID);
	if (games.empty())
	{
		GamePromptLayer::create()->showPrompt("Coming soon.");
		return;
	}
	_layerType = GAMELIST;

	if (!_layout_platform->isVisible())
	{
		_layout_platform->setVisible(true);
		showLobbyAction();
	}

	showGameListAction(false);
	showSortBtnAction(true);

	auto layout_games = (Layout*)_layout_platform->getChildByName("Panel_games");
	
	auto gamesLayer = GameLists::create(_KindID, layout_games);
	gamesLayer->setName("gamesLayer");
	gamesLayer->onCloseCallBack = [=](bool enterGame) {

		if (enterGame)
		{
			createRoomListLayer();
		}
		else
		{
			showGameListAction();
			_layerType = PLATFORM;
		}
	};

	gamesLayer->onRequestRoomList = [this]() {

		_platformlogic->requestRoomList();
		LoadingLayer::createLoading(Director::getInstance()->getRunningScene(), "Getting room list...", 22);
	};
	addChild(gamesLayer, GAMELIST_LAYER_ZORDER, CHILD_LAYER_GAMES_TAG);
}
```

