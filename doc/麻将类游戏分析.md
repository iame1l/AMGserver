### 麻将类游戏分析

```C++
#define MAKE_A_MJ(hs,pd)  ( (hs) * 10 +(pd))
```



```C++
	enum MJ_TYPE_PAI//牌类型
	{
		MJ_TYPE_PAI_NONE=-10,//lu无花色
		MJ_TYPE_PAI_WAN=0,//lu万
		MJ_TYPE_PAI_TIAO=1,//lu条
		MJ_TYPE_PAI_BING=2,//lu同
		MJ_TYPE_PAI_FENG=3,//lu风
		MJ_TYPE_PAI_HUA=4//lu花
	};
```



```C++
	enum MJ_TYPE_PAI_DIAN//lu牌点
	{
			MJ_TYPE_PAI_DIAN_NONE=-1,

			MJ_TYPE_PAI_DIAN_1 = 1,
			MJ_TYPE_PAI_DIAN_2 = 2,
			MJ_TYPE_PAI_DIAN_3 = 3,
			MJ_TYPE_PAI_DIAN_4 = 4,
			MJ_TYPE_PAI_DIAN_5 = 5,
			MJ_TYPE_PAI_DIAN_6 = 6,
			MJ_TYPE_PAI_DIAN_7 = 7,
			MJ_TYPE_PAI_DIAN_8 = 8,
			MJ_TYPE_PAI_DIAN_9 = 9
			
	}
```



```C++
	//	手牌不超过HAND_CARD_NUM张，0为结束标志	DWJ
	BYTE	m_byArHandPai[PLAY_COUNT][HAND_CARD_NUM];
```



```C++
struct MjMenPaiData 
{
	BYTE    byMenPai[300];				//麻将的数量，玩家个数，门牌最大敦数，每敦上下2张牌 
	BYTE    byNt;						//庄家位置
	BYTE	byStation;					//当前抓牌玩家的位置
	BYTE	byDir;						//当前抓牌方向(抓那个玩家门前的牌)
	BYTE	byGetPaiDir;				//本局起牌方向
	BYTE	byRemainDun;				//剩余敦数
	BYTE	byGetPai;				    //起牌敦数
	BYTE    byMenPaiDun[PLAY_COUNT];	//每个玩家门前的敦数
	BYTE    byStartIndex;				//门牌起始索引		
	BYTE    byEndIndex;				    //门牌结束索引		
	BYTE    byCaiShenIndex;				//财神位置索引		
	BYTE    byAllPaiNum;				//所有牌的数量
}
```



```C++
struct	tagZhuaPai
{
	BYTE	byDo;		//0未发生，10已结束，中间状态为正在发生
	BYTE	byUser;		//抓牌玩家位置
	BYTE	byPs;		//抓牌的值
	BYTE	byStartIndex;///开始索引
	BYTE	byEndIndex;  ///结束索引
	BYTE	byCaiShenIndex; ///财神索引
	BYTE	m_byArHandPai[PLAY_COUNT][HAND_CARD_NUM];//手牌数据
	BYTE	m_byArHandPaiCount[PLAY_COUNT];	//手牌张数
	BYTE	m_byArOutPai[PLAY_COUNT][OUT_CARD_NUM];//出牌不超过160张，0为结束标志
	BYTE	byMenPai[PLAY_COUNT][MEN_CARD_NUM];//门牌
	BYTE	m_byArHuaPai[PLAY_COUNT][HUA_CARD_NUM];//玩家花牌
	BYTE	byGetPaiIndex;//抓牌的索引
	bool	bHead;		//抓牌的方向
	bool	bCanOutPai;	//抓牌后是否可以出牌
	bool    m_bGangKai;	//是否杠开	
	bool    m_bBuHua;	//是否要补花	
	bool    bUserTing[4];		//玩家听牌状态
	BYTE	byNo;		//事件的代号
	BYTE	byNext;		//下一个事件的代号
	int		iRemaindCardCount;					//剩余牌数

};
```

