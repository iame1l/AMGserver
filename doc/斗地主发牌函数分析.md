### 斗地主发牌函数分析



1.两张为函数来发

```C++
//发送扑克给用户//发牌
BOOL CServerGameDesk::SendCard()
{
	if (m_iSendCardPos == m_iSendCount)
	{
		KillTimer(TIME_SEND_CARD);
		SendCardFinish();
		return TRUE;
	}
	//todo 配牌的信息因该写在这里
	//继续发送扑克(1次发两张)
	for(int i = 0; i < 2; i ++)
	{
		BYTE bDeskStation = (m_iDealPeople + m_iSendCardPos) % PLAY_COUNT;
		SendCardStruct SendCard;
		SendCard.bDeskStation = bDeskStation;
		SendCard.bCard = m_iUserCard[bDeskStation][m_iSendCardPos/PLAY_COUNT];

		for(int i = 0; i < PLAY_COUNT; i ++)
			SendGameDataEx(i,&SendCard,sizeof(SendCard),MDM_GM_GAME_NOTIFY,ASS_SEND_CARD,0);
		SendWatchData(m_bMaxPeople,&SendCard,sizeof(SendCard),MDM_GM_GAME_NOTIFY,ASS_SEND_CARD,0);

		SendCardMsg(bDeskStation,SendCard.bCard);

		m_iUserCardCount[bDeskStation] ++;
		m_iSendCardPos ++;
		if(m_iSendCardPos == m_iSendCount)
			break;
	}
	return TRUE;
}
```



2.一次完成发送到客户端

```C++
///一次發所有牌
/// 为防止外挂看牌器存在，只发自己的手牌，他人的手牌清空。
/// 旁观玩家不发任何牌，以免作弊现象
/// 由ZXD修改于20100314
BOOL	CServerGameDesk::SendAllCard()//mark
{
	SendAllStruct TSendAll;

	for(int i = 0; i < PLAY_COUNT; i ++)
	{
		m_iUserCardCount[i] = m_iUserCount;		
		TSendAll.iUserCardCount[i] = m_iUserCardCount[i];
	}
	//fixme 配牌需要查重
	LoadPeiPai();
	for(int i = 0; i < PLAY_COUNT; i ++)
	{
		TSendAll.iUserCardCount[i] = m_iUserCardCount[i];
	}

	//发送数据
	int iPos = 0;
	int iTempPos = 0 ;
	for(int i = 0;i < PLAY_COUNT; i ++)
	{
		int iTempPos = 0 ;
		for(int  j  = 0  ; j < PLAY_COUNT  ;j++)
		{
			if(i == j ||m_GameMutiple.sMingPaiMutiple[j] > 0)
			{
				::CopyMemory(&TSendAll.iUserCardList[iTempPos],m_iUserCard[j],sizeof(BYTE)*m_iUserCardCount[j]);
			}

			iTempPos += m_iUserCardCount[j] ; 
		}
	
		iPos += m_iUserCardCount[i];
		SendGameDataEx(i,&TSendAll,sizeof(TSendAll),MDM_GM_GAME_NOTIFY,ASS_SEND_ALL_CARD,0);
		SendWatchData(i,&TSendAll,sizeof(TSendAll),MDM_GM_GAME_NOTIFY,ASS_SEND_ALL_CARD,0);
		::ZeroMemory(&TSendAll.iUserCardList, sizeof(TSendAll.iUserCardList));
	}


	m_iSendCardPos ++;
	if(m_iSendCardPos == 1)
	{
		KillTimer(TIME_SEND_ALL_CARD);
		SetTimer(TIME_SEND_CARD_ANI , m_iSendCardTime *1000) ; ///给玩家发牌定时器
		return TRUE;
	}

	return FALSE;
}
```



```C++
//加载配牌
void CServerGameDesk::LoadPeiPai()
{
	CString nid;
	nid.Format("%d",NAME_ID);
	CString s = CINIFile::GetAppPath ();/////本地路径
	CINIFile f( s +nid +"_s.ini");
	CString key = TEXT("peipai");

	int isOpen = f.GetKeyVal("peipai","OPenPeiPai",0);
	if(isOpen == 0)
	{
		return;
	}
	if(1 == isOpen)
	{
		//手牌数量
		for(int i = 0; i < PLAY_COUNT; i ++)
		{
			CString str;
			str.Format("CardCount[%d]", i);
			m_iUserCardCount[i] = f.GetKeyVal("peipai", str, 17);
		}

		//// 0号玩家
		for(int i=1;i<=17;i++)
		{
			CString str;
			unsigned char ucTemp;
			str.Format("OneHand%02d",i);
			ucTemp = f.GetKeyVal("peipai",str, 255);
			m_iUserCard[0][i-1] = ucTemp;
		}
		//// 1号玩家
		for(int i=1;i<=17;i++)
		{
			CString str;
			unsigned char ucTemp;
			str.Format("TwoHand%02d",i);
			ucTemp = f.GetKeyVal("peipai",str,255);
			m_iUserCard[1][i-1] = ucTemp;
		}
		//// 2号玩家
		for(int i=1;i<=17;i++)
		{
			CString str;
			unsigned char ucTemp;
			str.Format("ThreeHand%02d",i);
			ucTemp = f.GetKeyVal("peipai",str,255);
			m_iUserCard[2][i-1] = ucTemp;
		}
		/// 门牌  
		for(int i=1;i <= m_iBackCount;i++)
		{
			CString str;
			unsigned char ucTemp;
			str.Format("Backpai%02d",i);
			ucTemp = f.GetKeyVal("peipai",str,255);
			m_iBackCard[i-1] = ucTemp;
		}
	}
	else if(2 == isOpen)
	{
		for(int i = 0; i < PLAY_COUNT; ++i)
		{
			if(m_pUserInfo[i] == nullptr) continue;
			int userID = m_pUserInfo[i]->m_UserData.dwUserID;
			char nameBuf[256];
			sprintf(nameBuf, "Card_%d", userID);
			CString cardListStr = f.GetKeyVal(key,nameBuf,"");
			if(cardListStr.GetLength() > 0)
			{
				for(int j = 1; j <= 17; j++)
				{
					m_iUserCard[i][j-1] = GetCardValue(cardListStr, j-1);
				}
			}
		}

		/// 门牌  
		for(int i=1;i <= m_iBackCount;i++)
		{
			CString str;
			unsigned char ucTemp;
			str.Format("Backpai%02d",i);
			ucTemp = f.GetKeyVal(key,str,255);
			if(255 != ucTemp)
			{
				m_iBackCard[i-1] = ucTemp;
			}
		}
	}
	else
	{
		return;
	}
}
```

